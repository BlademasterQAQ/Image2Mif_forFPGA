# batchImage2Mif(For FPGA)

​		本程序可以通过UI界面简单的将图片数据转为可存入FPGA中的文件格式mif

​		由于作者的项目需求和才疏学浅，**仅支持输出8bit的颜色**，如作者的FPGA项目中VGA模块数据线是2红3绿3蓝，2+3+3=8，否则mif文件不能正确的被Quartus打开。

​		在输出mif文件的页面会选择红绿蓝的排序方式，如作者的FPGA的VGA模块数据线高位至低位依次是**蓝绿红**，而声明的输入端口也是高位至低位(7 downto 0)，则应选择**BGR**。

​		~~不知道为什么ROM选择超过8条数据总线不会自动读入mif的下一个地址的数据🙃~~



**遇到的一些问题：**

​		本项目笔者第一次使用两个窗体，由于两个窗体的关系是独立的（一个UI线程发送阻塞时不会影响另一个的操作），它们将产生两个相互独立的UI线程，线程之间的通信就非常关键。

​		之前我也接触过多线程之间通信的问题，用网上找到的”同步块“的方法很好的解决了，比较麻烦的是同步块的建立和同步逻辑的理清。由于控件的监听事件比较容易入手，加上我之前听闻过用控件监听解决线程同步的问题，于是我这次尝试了一下，具体方法是在Frame主窗体中添加一个虚拟Button，在Dialog副窗体中获取这个控件，通过主窗体中的监听与副窗体中Button的doClick()模拟点击方法实现副窗体->主窗体的单向通信，即当副窗体的按钮被按下，模拟点击主窗体的按钮，触发这个按钮的监听，使主窗体执行监听器中的代码。对于主窗体->副窗体的通信，我通过在主窗体设置标志flag，在副窗口中通过while循环读取flag得到信息。

​		这里遇到几个问题：

1. 虚拟按钮模拟点击的响应较慢（相对于使用同步块），即使将flag清零放在虚拟按键监听的开头，若副窗体没有延时或其他的处理，当再次运行副窗体时，很可能会读到上一次运行的flag，导致出错。可以通过同步块、在副窗体运行结束时对主窗体的flag进行清零和设置延时三种方法处理，前面两种方法都会使得线程间的逻辑更加复杂，最后一种对后期维护不利。
2. 在UI线程中循环读取flag会阻塞UI线程，在死循环中对UI的操作无响应，只有结束循环才会刷新UI，**需要为循环读取flag的代码新建线程**。

**一些玄学：**

​		我在副窗体中创建了一个新线程，里面一个循环检测主窗体的当前运行进度flag，当当前进度未达到总进度前一直以它们的比值作为进度条的百分比。实际运行时发现，主窗体中正确的执行，也就是当前运行进度flag是一直在刷新的，但是副窗体不仅进度条一直为0，并且在while的前后放上System.out后发现一直在while中卡死。当我在while循环里放System.out准备检测while循环的情况时，程序突然正常运行了，且输出到控制台的数据也是正确的，当在while循环中插入断点调试（不含System.out）时也能正常运行，唯独无System.out时不能正常运行。开始我以为只有硬件存在玄学，原来软件中也是存在的。
